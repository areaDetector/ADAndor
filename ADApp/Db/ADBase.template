# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "$(P)$(R)PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control basic information                        #
#  about the detector                                             # 
###################################################################

record(stringin, "$(P)$(R)Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "$(P)$(R)Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "$(P)$(R)DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
}

record(mbbi, "$(P)$(R)DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "$(P)$(R)ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
}

record(mbbi, "$(P)$(R)ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the detector readout                     #
#  including binning, region start and size                       # 
###################################################################

record(longout, "$(P)$(R)BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BIN_X")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BIN_Y")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_X")
   field(VAL,  "0")
}

record(longin, "$(P)$(R)MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_Y")
   field(VAL,  "0")
}

record(longin, "$(P)$(R)MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SIZE_X")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SIZE_Y")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

record(bi, "$(P)$(R)ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
}

record(bi, "$(P)$(R)ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the acquisition time and                 #
#  period                                                         # 
###################################################################
record(ao, "$(P)$(R)AcquireTime")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQ_TIME")
   field(PREC, "3")
   field(VAL,  "1.0")
}

record(ai, "$(P)$(R)AcquireTime_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQ_TIME")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)AcquirePeriod")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQ_PERIOD")
   field(PREC, "3")
   field(VAL,  "0")
}

record(ai, "$(P)$(R)AcquirePeriod_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQ_PERIOD")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)TimeRemaining_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TIME_REMAINING")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the gain                                 # 
###################################################################
record(ao, "$(P)$(R)Gain")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))GAIN")
   field(VAL,  "1.0")
   field(PREC, "3")
}

record(ai, "$(P)$(R)Gain_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))GAIN")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the frame type                           # 
###################################################################
record(mbbo, "$(P)$(R)FrameType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(VAL,  "0")
}

record(mbbi, "$(P)$(R)FrameType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the acquisition mode                     # 
###################################################################
record(mbbo, "$(P)$(R)ImageMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(VAL,  "2")
}

record(mbbi, "$(P)$(R)ImageMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the trigger mode                         # 
###################################################################
record(mbbo, "$(P)$(R)TriggerMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(VAL,  "0")
}

record(mbbi, "$(P)$(R)TriggerMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the number of exposures and              #
#  number of images                                               # 
###################################################################
record(longout, "$(P)$(R)NumExposures")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NEXPOSURES")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)NumExposures_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NEXPOSURES")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)NumExposuresCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NEXPOSURES_COUNTER")
   field(SCAN, "I/O Intr")
}
record(longout, "$(P)$(R)NumImages")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NIMAGES")
   field(VAL,  "1")
}

record(longin, "$(P)$(R)NumImages_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NIMAGES")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)NumImagesCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NIMAGES_COUNTER")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control  acquisition start and                   # 
#  and stop                                                       #
###################################################################

record(busy, "$(P)$(R)Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
}

record(bi, "$(P)$(R)Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "$(P)$(R)ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
}

record(longin, "$(P)$(R)ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# This record needs work, because .B should reflect the time since last processed
record(calc, "$(P)$(R)ArrayRate_RBV")
{
    field(INPA, "$(P)$(R)ArrayRate_RBV.B NPP NMS")  # Previous counter value
    field(INPB, "$(P)$(R)ArrayCounter_RBV NPP NMS") # Current counter value
    field(INPC, "1.0")                              # Delta time, needs work
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}

###################################################################
#  These records are for the detector state                       # 
###################################################################

record(mbbi, "$(P)$(R)DetectorState_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))STATUS")
    field(ZRST, "Idle")
    field(ZRVL, "0")
    field(ZRSV, "NO_ALARM")
    field(ONST, "Acquire")
    field(ONVL, "1")
    field(ONSV, "NO_ALARM")
    field(TWST, "Readout")
    field(TWVL, "2")
    field(TWSV, "NO_ALARM")
    field(THST, "Correct")
    field(THVL, "3")
    field(THSV, "NO_ALARM")
    field(FRST, "Saving")
    field(FRVL, "4")
    field(FRSV, "NO_ALARM")
    field(FVST, "Aborting")
    field(FVVL, "5")
    field(FVSV, "MINOR")
    field(SXST, "Error")
    field(SXVL, "6")
    field(SXSV, "MAJOR")
    field(SVST, "Waiting")
    field(SVVL, "7")
    field(SVSV, "NO_ALARM")
    field(EIST, "Initializing")
    field(EIVL, "8")
    field(EISV, "NO_ALARM")
    field(NIST, "Disconnected")
    field(NIVL, "9")
    field(NISV, "INVALID")
    field(TEST, "Aborted")
    field(TEVL, "10")
    field(TESV, "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "$(P)$(R)ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

record(bi, "$(P)$(R)ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "$(P)$(R)NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
}

###################################################################
#  These records provide status information                       # 
###################################################################

# Status message.
record(waveform, "$(P)$(R)StatusMessage_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))STATUS_MESSAGE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(R)StringToServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))STRING_TO_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(R)StringFromServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))STRING_FROM_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

################################################################@###
#  This record can be used to force a read of the detector status  # 
####################################################################
record(bo,"$(P)$(R)ReadStatus") {
    field(DTYP,"asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))READ_STATUS")
    field(VAL, "1")
    field(SCAN,"Passive")
}

###################################################################
#  These records control the shutter                              # 
###################################################################

record(mbbo, "$(P)$(R)ShutterMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Detector output")
    field(TWVL, "2")
    field(VAL,  "0")
}

record(mbbi, "$(P)$(R)ShutterMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Camera output")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)ShutterControl")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(VAL,  "0")
}

record(bi, "$(P)$(R)ShutterControl_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(SCAN, "I/O Intr")
}

record(bi, "$(P)$(R)ShutterStatus_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_STATUS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ShutterOpenDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
}

record(ai, "$(P)$(R)ShutterOpenDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ShutterCloseDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
}

record(ai, "$(P)$(R)ShutterCloseDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

# This record changes state when the driver opens/closes an EPICS shutter
record(bi, "$(P)$(R)ShutterControlEPICS")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHUTTER_CONTROL_EPICS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)$(R)ShutterFanout.PROC")
}

record(fanout, "$(P)$(R)ShutterFanout")
{
    field(LNK1, "$(P)$(R)ShutterOpenEPICS.PROC PP MS")
    field(LNK2, "$(P)$(R)ShutterCloseEPICS.PROC PP MS")
}

record(calcout, "$(P)$(R)ShutterOpenEPICS")
{
    field(INPA, "$(P)$(R)ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "1")
    field(OUT,  "")
}

record(calcout, "$(P)$(R)ShutterCloseEPICS")
{
    field(INPA, "$(P)$(R)ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "0")
    field(OUT,  "")
}

record(mbbi, "$(P)$(R)ShutterStatusEPICS_RBV")
{
    field(DTYP, "Raw Soft Channel")
    field(INP,  "test CP MS")
    field(ZRVL, "0")
    field(ZRST, "Closed")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "Open")
    field(ONSV, "MINOR")
}

###################################################################
#  These records control the detector temperature                 # 
###################################################################
 
record(ao, "$(P)$(R)Temperature")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TEMPERATURE")
   field(PREC, "3")
   field(VAL,  "25.0")
}

record(ai, "$(P)$(R)Temperature_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TEMPERATURE")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)TemperatureActual")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TEMPERATURE_ACTUAL")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}


###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "$(P)$(R)PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "$(P)$(R)PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "$(P)$(R)PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "$(P)$(R)PoolAllocBuffers")
}

record(longin, "$(P)$(R)PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POOL_ALLOC_BUFFERS")
   field(FLNK, "$(P)$(R)PoolFreeBuffers")
}

record(longin, "$(P)$(R)PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POOL_FREE_BUFFERS")
   field(FLNK, "$(P)$(R)PoolUsedBuffers")
}

record(calc, "$(P)$(R)PoolUsedBuffers")
{
    field(INPA, "$(P)$(R)PoolAllocBuffers NPP MS")
    field(INPB, "$(P)$(R)PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"$(P)$(R)AsynIO")
{
    field(PORT, $(PORT))
    field(TIB2,"1")
    info("ADType", "ADDriver")
}

